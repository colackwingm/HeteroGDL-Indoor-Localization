import argparse
import dgl
import joblib
import torch

from _config import *
from _dataset import *


def normalize(array, _min=None, _max=None):
    if _min is None:
    # min is not specified
        _min = array.min()
    if _max is None:
        _max = array.max()
    return (array-_min)/(_max-_min)


def calDist(pos1, pos2):
    return math.sqrt((pos1[0]-pos2[0])**2 + (pos1[1]-pos2[1])**2)


def calInterferCoeff(pos1, pos2):
    return 0 - math.log10(calDist(pos1, pos2)) + math.log10(MAX_DIST)


def getGraphSkeleton(graphConfig):
    return dgl.heterograph(graphConfig)


parser = argparse.ArgumentParser(description="Choose the scenario and the dataset type...")
parser.add_argument("scenario_idx", type=int, choices=[1, 3], help="Choose the scenario by index (1 or 3)")
parser.add_argument("type", type=str, choices=['i', 'he', 'ho'], help="the type of data generated by this script (i=image, he=heterograph, ho=homogenerous graph)")
args = parser.parse_args()

if __name__ == '__main__':
    trY, trZ, trB, trW = joblib.load(TEMP_DIR + 'rawTR')
    teY, teZ, teB, teW = joblib.load(TEMP_DIR + 'rawTE')
    N_TR = trY.size(0)
    N_TE = teY.size(0)
    apL = torch.empty((3, 2))
    normTrY = torch.empty_like(trY)
    normTeY = torch.empty_like(teY)
    normApL = torch.empty_like(apL)

    idx = args.scenario_idx
    if idx == 1:
        # for scenario 1 (A, B, C)
        apL = torch.tensor([[0, 0], [0, 4], [4, 0]], dtype=torch.float32)
        # normalize coordinates
        normTrY = trY / 4
        normTeY = teY / 4
        normApL = apL / 4
    elif idx == 3:
        # for scenario 3 (A, B, C)
        apL = torch.tensor([[0, 0], [9.625, 0], [4.8125, 2.492]], dtype=torch.float32)
        # normalize coordinates
        normTrY[:, 0] = trY[:, 0] / 9.625
        normTeY[:, 0] = teY[:, 0] / 9.625
        normApL[:, 0] = apL[:, 0] / 9.625
        normTrY[:, 1] = trY[:, 1] / 2.492
        normTeY[:, 1] = teY[:, 1] / 2.492
        normApL[:, 1] = apL[:, 1] / 2.492

    # normalize zigbee
    normTrZ = normalize(0-trZ)
    normTeZ = normalize(0-teZ)
    # normalize bluetooth
    normTrB = normalize(0-trB)
    normTeB = normalize(0-teB)
    # normalize WiFi
    normTrW = normalize(0-trW)
    normTeW = normalize(0-teW)

    if args.type == 'i':
        print(f"Generating images for scenario {idx}...")
        trImage = torch.empty((N_TR, N_ZB+N_BT+N_WF, 3), dtype=torch.float32)
        trImage[:, :, 0] = torch.cat([normTrZ, normTrB, normTrW], 1)
        trImage[:, :, 1:] = normApL.repeat(N_TR, 3, 1)
        teImage = torch.empty((N_TE, N_ZB+N_BT+N_WF, 3), dtype=torch.float32)
        teImage[:, :, 0] = torch.cat([normTeZ, normTeB, normTeW], 1)
        teImage[:, :, 1:] = normApL.repeat(N_TE, 3, 1)
        trLabel = normTrY
        teLabel = normTeY
        joblib.dump([trImage, trLabel], TEMP_DIR + f'DatasetITR_S{idx}')
        joblib.dump([teImage, teLabel], TEMP_DIR + f'DatasetITE_S{idx}')
        print("Generated {:d} images for training, {:d} images for testing.".format(trImage.size(0), teImage.size(0)))
    elif args.type == 'he':
        print(f"Generating heterographs for scenario {idx}...")
        # PART 1. adjacency
        # 1.1: fully connection between Zigbee APs
        srcZB, tarZB, ZBCoeff = [], [], []
        for i in range(N_ZB):
            for j in range(N_ZB):
                if i != j:
                    srcZB.append(i)
                    tarZB.append(j)
                    ZBCoeff.append(calInterferCoeff(normApL[i], normApL[j]))
        # 1.2: fully connection between Bluetooth APs
        srcBT, tarBT, BTCoeff = [], [], []
        for i in range(N_BT):
            for j in range(N_BT):
                if i != j:
                    srcBT.append(i)
                    tarBT.append(j)
                    BTCoeff.append(calInterferCoeff(normApL[i], normApL[j]))
        # 1.3: fully connection between WiFi APs
        srcWF, tarWF, WFCoeff = [], [], []
        for i in range(N_WF):
            for j in range(N_WF):
                if i != j:
                    srcWF.append(i)
                    tarWF.append(j)
                    WFCoeff.append(calInterferCoeff(normApL[i], normApL[j]))
        # 1.4: from Zigbee APs to the testing device
        srcZB2TD, tarZB2TD = [], []
        for i in range(N_BT):
            srcZB2TD.append(i)
            tarZB2TD.append(0)
        # 1.5: from Bluetooth APs to the testing device
        srcBT2TD, tarBT2TD = [], []
        for i in range(N_BT):
            srcBT2TD.append(i)
            tarBT2TD.append(0)
        # 1.6: from WiFi APs to the testing device
        srcWF2TD, tarWF2TD = [], []
        for i in range(N_WF):
            srcWF2TD.append(i)
            tarWF2TD.append(0)

        # PART 2. graph skeleton
        graphConfig = {
            E_ZBZB: (torch.tensor(srcZB), torch.tensor(tarZB)),
            E_BTBT: (torch.tensor(srcBT), torch.tensor(tarBT)),
            E_WFWF: (torch.tensor(srcWF), torch.tensor(tarWF)),
            E_ZBTD: (torch.tensor(srcZB2TD), torch.tensor(tarZB2TD)),
            E_BTTD: (torch.tensor(srcBT2TD), torch.tensor(tarBT2TD)),
            E_WFTD: (torch.tensor(srcWF2TD), torch.tensor(tarWF2TD))
        }
        trGraph = []
        trLabel = normTrY
        teGraph = []
        teLabel = normTeY
        for i in range(N_TR):
            g = getGraphSkeleton(graphConfig)
            g.edges[E_ZBZB].data['interferCoeff'] = torch.tensor(ZBCoeff)
            g.edges[E_BTBT].data['interferCoeff'] = torch.tensor(BTCoeff)
            g.edges[E_WFWF].data['interferCoeff'] = torch.tensor(WFCoeff)
            g.nodes['ZB'].data['nodeFeature'] = torch.cat([normTrZ[i].unsqueeze(1), normApL], 1)
            g.nodes['BT'].data['nodeFeature'] = torch.cat([normTrB[i].unsqueeze(1), normApL], 1)
            g.nodes['WF'].data['nodeFeature'] = torch.cat([normTrW[i].unsqueeze(1), normApL], 1)
            trGraph.append(g)
        for i in range(N_TE):
            g = getGraphSkeleton(graphConfig)
            g.edges[E_ZBZB].data['interferCoeff'] = torch.tensor(ZBCoeff)
            g.edges[E_BTBT].data['interferCoeff'] = torch.tensor(BTCoeff)
            g.edges[E_WFWF].data['interferCoeff'] = torch.tensor(WFCoeff)
            g.nodes['ZB'].data['nodeFeature'] = torch.cat([normTeZ[i].unsqueeze(1), normApL], 1)
            g.nodes['BT'].data['nodeFeature'] = torch.cat([normTeB[i].unsqueeze(1), normApL], 1)
            g.nodes['WF'].data['nodeFeature'] = torch.cat([normTeW[i].unsqueeze(1), normApL], 1)
            teGraph.append(g)
        joblib.dump(PetrosGraphDataset('PetrosHeGTR', trGraph, trLabel), TEMP_DIR + f'DatasetHeGTR_S{idx}')
        joblib.dump(PetrosGraphDataset('PetrosHeGTE', teGraph, teLabel), TEMP_DIR + f'DatasetHeGTE_S{idx}')
        print("Generated {:d} heterographs for training, {:d} heterographs for testing.".format(len(trGraph), len(teGraph)))
    elif args.type == 'ho':
        print(f"Generating homogenerous graphs for scenario {idx}...")
        # adjacency
        # from test location to all APs
        src_0 = [0] * N_TOTAL_AP
        tar_0 = [i for i in range (1, N_TOTAL_AP+1)]
        # Zigbee APs are all connected
        src_1 = []
        tar_1 = []
        for i in range (1, N_ZB+1):
            for j in range (1, N_ZB+1):
                if i != j:
                    src_1.append(i)
                    tar_1.append(j)
        # Bluetooth beacons are all connected
        src_2 = []
        tar_2 = []
        for i in range (N_ZB+1, N_ZB+N_BT+1):
            for j in range (N_ZB+1, N_ZB+N_BT+1):
                if i != j:
                    src_2.append(i)
                    tar_2.append(j)
        # WiFi APs are all connected
        src_3 = []
        tar_3 = []
        for i in range (N_ZB+N_BT+1, N_TOTAL_AP+1):
            for j in range (N_ZB+N_BT+1, N_TOTAL_AP+1):
                if i != j:
                    src_3.append(i)
                    tar_3.append(j)
        # connect all of them
        src = src_0 + src_1 + src_2 + src_3
        tar = tar_0 + tar_1 + tar_2 + tar_3

        trGraph, teGraph = [], []
        trLabel = normTrY
        teLabel = normTeY
        locs = torch.cat([normApL]*3, axis=0)
        trRSS = torch.cat([normTrZ, normTrB, normTrW], axis=1)
        teRSS = torch.cat([normTeZ, normTeB, normTeW], axis=1)
        for i in range(N_TR):
            g = dgl.graph((src, tar))
            g = dgl.to_bidirected(g)
            nodeFeat = torch.empty((N_TOTAL_AP, 3))
            nodeFeat[:, 0] = trRSS[i]
            nodeFeat[:, 1:] = locs
            g.ndata['x'] = torch.cat([torch.zeros((1, 3)), nodeFeat], axis=0)
            trGraph.append(g)
        for i in range(N_TE):
            g = dgl.graph((src, tar))
            g = dgl.to_bidirected(g)
            nodeFeat = torch.empty((N_TOTAL_AP, 3))
            nodeFeat[:, 0] = teRSS[i]
            nodeFeat[:, 1:] = locs
            g.ndata['x'] = torch.cat([torch.zeros((1, 3)), nodeFeat], axis=0)
            teGraph.append(g)
        joblib.dump(PetrosGraphDataset('PetrosHoGTR', trGraph, trLabel), TEMP_DIR + f'DatasetHoGTR_S{idx}')
        joblib.dump(PetrosGraphDataset('PetrosHoGTE', teGraph, teLabel), TEMP_DIR + f'DatasetHoGTE_S{idx}')
        print("Generated {:d} homogenerous graphs for training, {:d} homogenerous graphs for testing.".format(len(trGraph), len(teGraph)))
