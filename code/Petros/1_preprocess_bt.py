import argparse
import dgl
import joblib
import torch

from _config import *
from _dataset import *


def normalize(array, _min=None, _max=None):
    if _min is None:
    # min is not specified
        _min = array.min()
    if _max is None:
        _max = array.max()
    return (array-_min)/(_max-_min)


def calDist(pos1, pos2):
    return math.sqrt((pos1[0]-pos2[0])**2 + (pos1[1]-pos2[1])**2)


def calInterferCoeff(pos1, pos2):
    return 0 - math.log10(calDist(pos1, pos2)) + math.log10(MAX_DIST)


def getGraphSkeleton(graphConfig):
    return dgl.heterograph(graphConfig)


parser = argparse.ArgumentParser(description="Choose the scenario and the dataset type...")
parser.add_argument("scenario_idx", type=int, choices=[1, 3], help="Choose the scenario by index (1 or 3)")
parser.add_argument("type", type=str, choices=['i', 'g'], help="the type of data generated by this script (i=image, g=graph)")
args = parser.parse_args()

if __name__ == '__main__':
    trY, _, trB, _ = joblib.load(TEMP_DIR + 'rawTR')
    teY, _, teB, _ = joblib.load(TEMP_DIR + 'rawTE')
    N_TR = trY.size(0)
    N_TE = teY.size(0)
    apL = torch.empty((3, 2))
    normTrY = torch.empty_like(trY)
    normTeY = torch.empty_like(teY)
    normApL = torch.empty_like(apL)

    idx = args.scenario_idx
    if idx == 1:
        # for scenario 1 (A, B, C)
        apL = torch.tensor([[0, 0], [0, 4], [4, 0]], dtype=torch.float32)
        # normalize coordinates
        normTrY = trY / 4
        normTeY = teY / 4
        normApL = apL / 4
    elif idx == 3:
        # for scenario 3 (A, B, C)
        apL = torch.tensor([[0, 0], [9.625, 0], [4.8125, 2.492]], dtype=torch.float32)
        # normalize coordinates
        normTrY[:, 0] = trY[:, 0] / 9.625
        normTeY[:, 0] = teY[:, 0] / 9.625
        normApL[:, 0] = apL[:, 0] / 9.625
        normTrY[:, 1] = trY[:, 1] / 2.492
        normTeY[:, 1] = teY[:, 1] / 2.492
        normApL[:, 1] = apL[:, 1] / 2.492

    # normalize bluetooth
    normTrB = normalize(0-trB)
    normTeB = normalize(0-teB)

    if args.type == 'i':
        print(f"Generating images for scenario {idx}...")
        trImage = torch.empty((N_TR, N_BT, 3), dtype=torch.float32)
        trImage[:, :, 0] = normTrB
        trImage[:, :, 1:] = normApL.repeat(N_TR, 1, 1)
        teImage = torch.empty((N_TE, N_BT, 3), dtype=torch.float32)
        teImage[:, :, 0] = normTeB
        teImage[:, :, 1:] = normApL.repeat(N_TE, 1, 1)
        trLabel = normTrY
        teLabel = normTeY
        joblib.dump([trImage, trLabel], TEMP_DIR + f'DatasetITR_S{idx}_BT')
        joblib.dump([teImage, teLabel], TEMP_DIR + f'DatasetITE_S{idx}_BT')
        print("Generated {:d} images for training, {:d} images for testing.".format(trImage.size(0), teImage.size(0)))
    elif args.type == 'g':
        print(f"Generating heterographs for scenario {idx}...")
        # PART 1. adjacency
        # 1.2: fully connection between Bluetooth APs
        srcBT, tarBT, BTCoeff = [], [], []
        for i in range(N_BT):
            for j in range(N_BT):
                if i != j:
                    srcBT.append(i)
                    tarBT.append(j)
                    BTCoeff.append(calInterferCoeff(normApL[i], normApL[j]))
        # 1.5: from Bluetooth APs to the testing device
        srcBT2TD, tarBT2TD = [], []
        for i in range(N_BT):
            srcBT2TD.append(i)
            tarBT2TD.append(0)

        # PART 2. graph skeleton
        graphConfig = {
            E_BTBT: (torch.tensor(srcBT), torch.tensor(tarBT)),
            E_BTTD: (torch.tensor(srcBT2TD), torch.tensor(tarBT2TD))
        }
        trGraph = []
        trLabel = normTrY
        teGraph = []
        teLabel = normTeY
        for i in range(N_TR):
            g = getGraphSkeleton(graphConfig)
            g.edges[E_BTBT].data['interferCoeff'] = torch.tensor(BTCoeff)
            g.nodes['BT'].data['nodeFeature'] = torch.cat([normTrB[i].unsqueeze(1), normApL], 1)
            trGraph.append(g)
        for i in range(N_TE):
            g = getGraphSkeleton(graphConfig)
            g.edges[E_BTBT].data['interferCoeff'] = torch.tensor(BTCoeff)
            g.nodes['BT'].data['nodeFeature'] = torch.cat([normTeB[i].unsqueeze(1), normApL], 1)
            teGraph.append(g)
        joblib.dump(PetrosGraphDataset('PetrosHeGTR', trGraph, trLabel), TEMP_DIR + f'DatasetHeGTR_S{idx}_BT')
        joblib.dump(PetrosGraphDataset('PetrosHeGTE', teGraph, teLabel), TEMP_DIR + f'DatasetHeGTE_S{idx}_BT')
        print("Generated {:d} heterographs for training, {:d} heterographs for testing.".format(len(trGraph), len(teGraph)))
