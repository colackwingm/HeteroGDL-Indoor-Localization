import argparse
import dgl
import joblib
import numpy
import torch

from matplotlib import pyplot as plt

from _config import *
from _dataset import *


def normalize(array, _min=None, _max=None):
    if _min is None:
    # min is not specified
        _min = array.min()
    if _max is None:
        _max = array.max()
    return (array-_min)/(_max-_min)


def getGraphSkeleton(graphConfig):
    return dgl.heterograph(graphConfig)


def calDist(pos1, pos2):
    return math.sqrt((pos1[0]-pos2[0])**2 + (pos1[1]-pos2[1])**2)


def calInterferCoeff(pos1, pos2):
    return 0 - math.log10(calDist(pos1, pos2)) + math.log10(MAX_DIST)


parser = argparse.ArgumentParser(description="Data preprocessing")
parser.add_argument("type", type=str, choices=['i', 'he', 'ho'], help="the type of data generated by this script (i=image, he=heterograph, ho=homogenerous graph)")
args = parser.parse_args()

if __name__ == '__main__':
    # info
    locAP = joblib.load(TEMP_DIR + 'locAP')
    locBT = joblib.load(TEMP_DIR + 'locBT')
    # x
    trRSS = joblib.load(TEMP_DIR + 'tr_x')
    teRSS = joblib.load(TEMP_DIR + 'te_x')
    N_TR = trRSS.shape[0]
    N_TE = teRSS.shape[0]
    # y
    trPos = joblib.load(TEMP_DIR + 'tr_y')
    tePos = joblib.load(TEMP_DIR + 'te_y')

    # # normalization of rssi
    trRSS = normalize(trRSS, _min=-110, _max=-30)
    teRSS = normalize(teRSS, _min=-110, _max=-30)

    # normalization of location
    # in paper, x: [0, 50], y: [0. 38]
    normLocAP = numpy.concatenate((
        normalize(locAP[:, 0], _min=0, _max=50)[:, numpy.newaxis],
        normalize(locAP[:, 1], _min=0, _max=38)[:, numpy.newaxis]
    ), axis=1)
    normLocBT = numpy.concatenate((
        normalize(locBT[:, 0], _min=0, _max=50)[:, numpy.newaxis],
        normalize(locBT[:, 1], _min=0, _max=38)[:, numpy.newaxis]
    ), axis=1)
    normTrPos = numpy.concatenate((
        normalize(trPos[:, 0], _min=0, _max=50)[:, numpy.newaxis],
        normalize(trPos[:, 1], _min=0, _max=38)[:, numpy.newaxis]
    ), axis=1)
    normTePos = numpy.concatenate((
        normalize(tePos[:, 0], _min=0, _max=50)[:, numpy.newaxis],
        normalize(tePos[:, 1], _min=0, _max=38)[:, numpy.newaxis]
    ), axis=1)

    if args.type == 'he':
        print("Generating heterographs...")
        # adjacency
        # Part 1: fully connection between WiFi APs
        srcWF, tarWF, WFCoeff = [], [], []
        for i in range(N_WIFI):
            for j in range(N_WIFI):
                if i != j:
                    srcWF.append(i)
                    tarWF.append(j)
                    WFCoeff.append(calInterferCoeff(normLocAP[i], normLocAP[j]))
        # Part 2: fully connection between Bluetooth APs
        srcBT, tarBT, BTCoeff = [], [], []
        for i in range(N_BLUE):
            for j in range(N_BLUE):
                if i != j:
                    srcBT.append(i)
                    tarBT.append(j)
                    BTCoeff.append(calInterferCoeff(normLocBT[i], normLocBT[j]))
        # Part 3: from WiFi APs to the testing device
        srcWF2TD, tarWF2TD = [], []
        for i in range(N_WIFI):
            srcWF2TD.append(i)
            tarWF2TD.append(0)
        # Part 4: from Bluetooth APs to the testing device
        srcBT2TD, tarBT2TD = [], []
        for i in range(N_BLUE):
            srcBT2TD.append(i)
            tarBT2TD.append(0)
        # graph skeleton
        graphConfig = {
           E_WFWF: (torch.tensor(srcWF), torch.tensor(tarWF)),
           E_BTBT: (torch.tensor(srcBT), torch.tensor(tarBT)),
           E_WFTD: (torch.tensor(srcWF2TD), torch.tensor(tarWF2TD)),
           E_BTTD: (torch.tensor(srcBT2TD), torch.tensor(tarBT2TD))
        }

        trGraph, trLabel = [], []
        teGraph, teLabel = [], []

        for i in range(N_TR):
            g = getGraphSkeleton(graphConfig)
            g.edges[E_WFWF].data['interferCoeff'] = torch.tensor(WFCoeff)
            g.edges[E_BTBT].data['interferCoeff'] = torch.tensor(BTCoeff)
            WFFeat = numpy.concatenate((trRSS[i][:N_WIFI, numpy.newaxis], normLocAP), axis=1).astype(numpy.float32)
            BTFeat = numpy.concatenate((trRSS[i][N_WIFI:, numpy.newaxis], normLocBT), axis=1).astype(numpy.float32)
            g.nodes['WF'].data['nodeFeature'] = torch.from_numpy(WFFeat)
            g.nodes['BT'].data['nodeFeature'] = torch.from_numpy(BTFeat)
            trGraph.append(g)
            trLabel.append(torch.from_numpy(normTrPos[i].astype(numpy.float32)))

        for i in range(N_TE):
            g = getGraphSkeleton(graphConfig)
            g.edges[E_WFWF].data['interferCoeff'] = torch.tensor(WFCoeff)
            g.edges[E_BTBT].data['interferCoeff'] = torch.tensor(BTCoeff)
            WFFeat = numpy.concatenate((teRSS[i][:N_WIFI, numpy.newaxis], normLocAP), axis=1).astype(numpy.float32)
            BTFeat = numpy.concatenate((teRSS[i][N_WIFI:, numpy.newaxis], normLocBT), axis=1).astype(numpy.float32)
            g.nodes['WF'].data['nodeFeature'] = torch.from_numpy(WFFeat)
            g.nodes['BT'].data['nodeFeature'] = torch.from_numpy(BTFeat)
            teGraph.append(g)
            teLabel.append(torch.from_numpy(normTePos[i].astype(numpy.float32)))

        joblib.dump(SoLocGraphDataset('SoLocHeGTR', trGraph, trLabel), TEMP_DIR + 'DatasetHeGTR')
        joblib.dump(SoLocGraphDataset('SoLocHeGTE', teGraph, teLabel), TEMP_DIR + 'DatasetHeGTE')
        print("Generated {:d} heterographs for training, {:d} heterographs for testing.".format(len(trGraph), len(teGraph)))
    elif args.type == 'ho':
        print("Generating homogenerous graphs...")
        # adjacency
        # from test location to all APs
        src_0 = [0] * N_AP
        tar_0 = [i for i in range (1, N_AP+1)]
        # WiFi APs are all connected
        src_1 = []
        tar_1 = []
        for i in range (1, N_WIFI+1):
            for j in range (1, N_WIFI+1):
                if i != j:
                    src_1.append(i)
                    tar_1.append(j)
        # BLE beacons are all connected
        src_2 = []
        tar_2 = []
        for i in range (N_WIFI+1, N_AP+1):
            for j in range (N_WIFI+1, N_AP+1):
                if i != j:
                    src_2.append(i)
                    tar_2.append(j)
        # connect all of them
        src = src_0 + src_1 + src_2
        tar = tar_0 + tar_1 + tar_2

        trGraph, trLabel = [], []
        teGraph, teLabel = [], []
        locs = numpy.concatenate((normLocAP, normLocBT), axis=0)
        for i in range(N_TR):
            g = dgl.graph((src, tar))
            g = dgl.to_bidirected(g)
            nodeFeat = numpy.empty((N_AP, 3))
            nodeFeat[:, 0] = trRSS[i]
            nodeFeat[:, 1:] = locs
            nodeFeat = numpy.concatenate((numpy.zeros((1, 3)), nodeFeat), axis=0)
            g.ndata['x'] = torch.from_numpy(nodeFeat.astype(numpy.float32))
            trGraph.append(g)
            trLabel.append(torch.from_numpy(normTrPos[i].astype(numpy.float32)))
        for i in range(N_TE):
            g = dgl.graph((src, tar))
            g = dgl.to_bidirected(g)
            nodeFeat = numpy.empty((N_AP, 3))
            nodeFeat[:, 0] = teRSS[i]
            nodeFeat[:, 1:] = locs
            nodeFeat = numpy.concatenate((numpy.zeros((1, 3)), nodeFeat), axis=0)
            g.ndata['x'] = torch.from_numpy(nodeFeat.astype(numpy.float32))
            teGraph.append(g)
            teLabel.append(torch.from_numpy(normTePos[i].astype(numpy.float32)))
        joblib.dump(SoLocGraphDataset('SoLocHoGTR', trGraph, trLabel), TEMP_DIR + 'DatasetHoGTR')
        joblib.dump(SoLocGraphDataset('SoLocHoGTE', teGraph, teLabel), TEMP_DIR + 'DatasetHoGTE')
        print("Generated {:d} homogenerous graphs for training, {:d} homogenerous graphs for testing.".format(len(trGraph), len(teGraph)))
    else:
        print("Generating images...")

        trImage = torch.empty((N_TR, N_WIFI+N_BLUE, 3), dtype=torch.float32)
        trLabel = torch.empty((N_TR, 2), dtype=torch.float32)
        teImage = torch.empty((N_TE, N_WIFI+N_BLUE, 3), dtype=torch.float32)
        teLabel = torch.empty((N_TE, 2), dtype=torch.float32)

        trImage[:, :, 0] = torch.from_numpy(trRSS.astype(numpy.float32))
        teImage[:, :, 0] = torch.from_numpy(teRSS.astype(numpy.float32))
        for i in range(N_TR):
            trImage[i, :11, 1:] = torch.from_numpy(normLocAP.astype(numpy.float32))
            trImage[i, 11:, 1:] = torch.from_numpy(normLocBT.astype(numpy.float32))
            trLabel[i] = torch.from_numpy(normTrPos[i].astype(numpy.float32))
        for i in range(N_TE):
            teImage[i, :11, 1:] = torch.from_numpy(normLocAP.astype(numpy.float32))
            teImage[i, 11:, 1:] = torch.from_numpy(normLocBT.astype(numpy.float32))
            teLabel[i] = torch.from_numpy(normTePos[i].astype(numpy.float32))
        joblib.dump([trImage, trLabel], TEMP_DIR + 'DatasetITR')
        joblib.dump([teImage, teLabel], TEMP_DIR + 'DatasetITE')
        print("Generated {:d} images for training, {:d} images for testing.".format(trImage.size()[0], teImage.size()[0]))
