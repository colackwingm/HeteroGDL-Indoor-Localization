import argparse
import dgl
import joblib
import numpy
import torch

from matplotlib import pyplot as plt

from _config import *
from _dataset import *


def normalize(array, _min=None, _max=None):
    if _min is None:
    # min is not specified
        _min = array.min()
    if _max is None:
        _max = array.max()
    return (array-_min)/(_max-_min)


def getGraphSkeleton(graphConfig):
    return dgl.heterograph(graphConfig)


def calDist(pos1, pos2):
    return math.sqrt((pos1[0]-pos2[0])**2 + (pos1[1]-pos2[1])**2)


def calInterferCoeff(pos1, pos2):
    return 0 - math.log10(calDist(pos1, pos2)) + math.log10(MAX_DIST)


parser = argparse.ArgumentParser(description="Data preprocessing")
parser.add_argument("type", type=str, choices=['i', 'g'], help="the type of data generated by this script (i=image, g=graph")
args = parser.parse_args()

if __name__ == '__main__':
    # info
    locAP = joblib.load(TEMP_DIR + 'locAP')
    # x
    trRSS = joblib.load(TEMP_DIR + 'tr_x')
    teRSS = joblib.load(TEMP_DIR + 'te_x')
    N_TR = trRSS.shape[0]
    N_TE = teRSS.shape[0]
    # y
    trPos = joblib.load(TEMP_DIR + 'tr_y')
    tePos = joblib.load(TEMP_DIR + 'te_y')

    # # normalization of rssi
    trRSS = normalize(trRSS, _min=-110, _max=-30)[:, :N_WIFI]
    teRSS = normalize(teRSS, _min=-110, _max=-30)[:, :N_WIFI]

    # normalization of location
    # in paper, x: [0, 50], y: [0. 38]
    normLocAP = numpy.concatenate((
        normalize(locAP[:, 0], _min=0, _max=50)[:, numpy.newaxis],
        normalize(locAP[:, 1], _min=0, _max=38)[:, numpy.newaxis]
    ), axis=1)
    normTrPos = numpy.concatenate((
        normalize(trPos[:, 0], _min=0, _max=50)[:, numpy.newaxis],
        normalize(trPos[:, 1], _min=0, _max=38)[:, numpy.newaxis]
    ), axis=1)
    normTePos = numpy.concatenate((
        normalize(tePos[:, 0], _min=0, _max=50)[:, numpy.newaxis],
        normalize(tePos[:, 1], _min=0, _max=38)[:, numpy.newaxis]
    ), axis=1)

    if args.type == 'g':
        print("Generating heterographs...")
        # adjacency
        # Part 1: fully connection between WiFi APs
        srcWF, tarWF, WFCoeff = [], [], []
        for i in range(N_WIFI):
            for j in range(N_WIFI):
                if i != j:
                    srcWF.append(i)
                    tarWF.append(j)
                    WFCoeff.append(calInterferCoeff(normLocAP[i], normLocAP[j]))
        # Part 2: from WiFi APs to the testing device
        srcWF2TD, tarWF2TD = [], []
        for i in range(N_WIFI):
            srcWF2TD.append(i)
            tarWF2TD.append(0)
        # graph skeleton
        graphConfig = {
           E_WFWF: (torch.tensor(srcWF), torch.tensor(tarWF)),
           E_WFTD: (torch.tensor(srcWF2TD), torch.tensor(tarWF2TD))
        }

        trGraph, trLabel = [], []
        teGraph, teLabel = [], []

        for i in range(N_TR):
            g = getGraphSkeleton(graphConfig)
            g.edges[E_WFWF].data['interferCoeff'] = torch.tensor(WFCoeff)
            WFFeat = numpy.concatenate((trRSS[i][:N_WIFI, numpy.newaxis], normLocAP), axis=1).astype(numpy.float32)
            g.nodes['WF'].data['nodeFeature'] = torch.from_numpy(WFFeat)
            trGraph.append(g)
            trLabel.append(torch.from_numpy(normTrPos[i].astype(numpy.float32)))

        for i in range(N_TE):
            g = getGraphSkeleton(graphConfig)
            g.edges[E_WFWF].data['interferCoeff'] = torch.tensor(WFCoeff)
            WFFeat = numpy.concatenate((teRSS[i][:N_WIFI, numpy.newaxis], normLocAP), axis=1).astype(numpy.float32)
            g.nodes['WF'].data['nodeFeature'] = torch.from_numpy(WFFeat)
            teGraph.append(g)
            teLabel.append(torch.from_numpy(normTePos[i].astype(numpy.float32)))

        joblib.dump(SoLocGraphDataset('SoLocHeGTR', trGraph, trLabel), TEMP_DIR + 'DatasetGTR_WF')
        joblib.dump(SoLocGraphDataset('SoLocHeGTE', teGraph, teLabel), TEMP_DIR + 'DatasetGTE_WF')
        print("Generated {:d} graphs for training, {:d} graphs for testing.".format(len(trGraph), len(teGraph)))
    else:
        print("Generating images...")
        trImage = torch.empty((N_TR, N_WIFI, 3), dtype=torch.float32)
        trLabel = torch.empty((N_TR, 2), dtype=torch.float32)
        teImage = torch.empty((N_TE, N_WIFI, 3), dtype=torch.float32)
        teLabel = torch.empty((N_TE, 2), dtype=torch.float32)

        trImage[:, :, 0] = torch.from_numpy(trRSS.astype(numpy.float32))
        teImage[:, :, 0] = torch.from_numpy(teRSS.astype(numpy.float32))
        for i in range(N_TR):
            trImage[i, :, 1:] = torch.from_numpy(normLocAP.astype(numpy.float32))
            trLabel[i] = torch.from_numpy(normTrPos[i].astype(numpy.float32))
        for i in range(N_TE):
            teImage[i, :, 1:] = torch.from_numpy(normLocAP.astype(numpy.float32))
            teLabel[i] = torch.from_numpy(normTePos[i].astype(numpy.float32))
        joblib.dump([trImage, trLabel], TEMP_DIR + 'DatasetITR_WF')
        joblib.dump([teImage, teLabel], TEMP_DIR + 'DatasetITE_WF')
        print("Generated {:d} images for training, {:d} images for testing.".format(trImage.size()[0], teImage.size()[0]))
